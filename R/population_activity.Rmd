---
title: "R Notebook"
output: html_notebook
---
```{r}
library(dplyr)
library(pracma)
library(purrr)
library(readr)
library(tidyr)
library(stringr)
library(data.table)
library(datatrace)
source('utils.R')
source('traces_input.R')
source('plotting_params.R')
source('tracking_info.R')

perc2dist = 1.2
```


```{r}
timebin.dur.msec = 100
root_dir = '/mnt/DATA/Prez/cheeseboard-down/down_2/2019-08/'
animal_name = 'F-TL'
exp_title='learning'
#day = '2019-09-03'
day = '2019-09-05'

# root_dir = '/mnt/DATA/Prez/cheeseboard-down/down_2/2020-01/'
# animal_name = 'G-BR'
# exp_title='learning'
# day = '2020-02-05'

caimg_result_dir = find.caimg.dir(caimg_result_dirs, animal_name, day)
data.traces = read.data.trace(caimg_result_dir)
# running speed avg > 4 cm/s in 0.5 s window
data.traces = add.running.col(data.traces, 3.3, 10)
setorder(data.traces, exp_title, trial_id, cell_id, timestamp)
detect.events(data.traces, deconv.threshold=0.2)

setDT(data.traces)[, `:=` (norm_deconv_trace = deconv_trace / max(deconv_trace),
                           norm_trace = trace / max(trace),
                           atReward = atReward0 + atReward1), 
                   by=.(cell_id)]
data.traces[, moved_distance := cumsum(c(0, norm2(diff(x), diff(y)))), 
            by = .(animal, date, exp_title, trial_id, trial, cell_id)]

binned.traces = timebin.traces(data.traces[x > 0 & y > 0 & exp_title=='trial', ],
                               timebin.dur.msec=timebin.dur.msec) %>%
  dplyr::group_by(exp_title, trial) %>%
  dplyr::mutate(trial_time_bin = time_bin - min(time_bin)) %>%
  as.data.table()

binned.traces$atReward = as.factor(ifelse(binned.traces$atReward > 0.5, 'at_reward', 'not_at_reward'))
deconv_trace.matrix = reshape2::acast(binned.traces, time_bin ~ cell_id, value.var='norm_deconv_trace')
behav.traces = binned.traces[cell_id == binned.traces$cell_id[1], 
                             .(trial, timestamp, time_bin, trial_time_bin, x, y, angle, 
                               atReward, atReward0, atReward1, 
                               is_headdip, is_running, velocity, dist_reward0, dist_reward1, moved_distance)]
```
Population activity
```{r}
pop.traces = binned.traces[, .(pop.events=sum(nevents) / .N, 
                               nactive=sum(nevents),
                               trace.mean=mean(norm_deconv_trace)),
                           by=c('trial', 'time_bin', 'x', 'y', 'arrivedAtReward', 'velocity', 'atReward0', 'atReward1', 'is_headdip', 'is_running')] 
pop.traces
```
Draw population activity
```{r}
large.pop.events = filter(pop.traces, pop.events > 0.05)
pop.traces$trial = as.factor(pop.traces$trial)
ggplot(pop.traces) +
  geom_path(aes(x=x, y=100-y, group=trial), size=0.5) +
  #scale_colour_gradient2(low='blue', mid='white', high='red', midpoint = 0.05) +
  geom_point(data=large.pop.events, mapping=aes(x=x, y=100-y), color='red') +
  geom_rewards(rewards.df, data.traces$animal[1], data.traces$date[1], nbins = 100, 
               rew.colours = list(current_rew='black')) +
  #facet_wrap(trial ~ .) +
  theme_void()
```
# Activity vs running velocity

Calculate total pop activity
```{r}
total.deconv.activity = rowSums(deconv_trace.matrix) / nrow(deconv_trace.matrix)
behav.traces$total_activity = total.deconv.activity
behav.traces = behav.traces %>%
  dplyr::mutate(velocity = ifelse(velocity > 100, 100, velocity))
behav.traces = as.data.table(behav.traces)

wide.behav.traces = behav.traces %>%
  pivot_longer(c(x, y, is_headdip, is_running, velocity, total_activity, 
                 atReward0, atReward1, 
                 dist_reward0, dist_reward1, moved_distance),
               names_to='metric', values_to='value')
```

Activity raster, cells sorted using t-sne on correlation matix
```{r}
selected.trial = 8

g.behav = wide.behav.traces %>%
  filter(trial==selected.trial) %>%
  filter(metric %in% c('velocity', 'total_activity', 'is_running')) %>% 
  filter(value < 50) %>%
  ggplot(aes(x=trial_time_bin * (timebin.dur.msec / 1000), y=value)) +
  geom_line() +
  facet_grid(metric ~ ., scales='free_y') +
  xlab('Time (s)')
```

Sort cells by the time of max trace value
```{r}
trial.traces = binned.traces[trial == selected.trial,]

order.cells.by.max.val = function(trial.traces, value.varname='norm_deconv_trace', active.val.threshold=0.05) {
  trial.traces$cell_id = as.factor(trial.traces$cell_id)
  trial_trace.matrix = reshape2::acast(trial.traces, time_bin ~ cell_id, value.var=value.varname)
  cell.max.time.i = apply(trial_trace.matrix, 2, which.max)
  cell.max.val = apply(trial_trace.matrix, 2, max)
  cell.order.df = data.frame(cell_id=as.integer(colnames(trial_trace.matrix)), 
                             max.time.i=cell.max.time.i,
                             cell.max.val=cell.max.val) %>%                
    dplyr::mutate(is.active=cell.max.val > active.val.threshold) %>%
    dplyr::arrange(desc(is.active), cell.max.time.i) %>%                                                       
    dplyr::mutate(cell_order = as.integer(dplyr::row_number())) %>%
    as.data.table()
  
  return(cell.order.df)
}

cell.order.df = order.cells.by.max.val(trial.traces)
```

```{r}
plot.time.activity.raster = function(df, fill.var=norm_trace) {
  fill.var = enquo(fill.var)
  ggplot(df) +
  geom_raster(aes(x=trial_time_bin * (timebin.dur.msec / 1000), 
                  y=as.integer(cell_order), 
                  fill=!!fill.var),
              width=0.5) +
  geom_tile(aes(x=trial_time_bin * (timebin.dur.msec / 1000), y=-2, color=atReward)) +
  xlab('Time (s)') +
  ylab('Cell') +
  gtheme +
  theme(legend.position = 'none') +
  scale_fill_gradient(low='white', high = 'black') +
  scale_color_manual(values=c('#0098ffff', 'white')) +
  scale_y_reverse()
}

plot.binned.traces = binned.traces[trial %in% c(6, 7, 8),]
joined.binned.traces = plot.binned.traces[cell.order.df, on='cell_id']
g.raster = plot.time.activity.raster(
    joined.binned.traces[is.active==TRUE,]) +
    facet_grid(trial ~ .)

plot_grid(g.raster, g.behav, ncol=1, rel_heights = c(2, 1))
```

TOOO: identify walking bouts
```{r}

```


```{r}
df = binned.traces[trial == selected.trial & timestamp > 35 * 1000, ]
cell.order.df = order.cells.by.max.val(df, active.val.threshold = 0.1)
df.joined = df[cell.order.df, on = .(cell_id)]
plot.time.activity.raster(df.joined[is.active==TRUE], norm_deconv_trace)
```

```{r}
goal.cell.max.dist = 20
library(MASS)
regressed.df = df.joined %>%
  filter(is.active) %>%
  filter(nevents > 0) %>%
  filter(timestamp > 35 * 1000) %>%
  dplyr::mutate(trial.time.sec = trial_time_bin * (timebin.dur.msec / 1000))

#seq.model = lm(cell_order ~ trial.time.sec, data=regressed.df)
seq.model = MASS::ltsreg(cell_order ~ trial.time.sec, data=regressed.df)
summary(seq.model)
seq.model$coefficients

in.reward.zone.sec = df.joined[cell_id == regressed.df$cell_id[1] & dist_reward1 < goal.cell.max.dist * perc2dist, 
                               .(trial.time.sec = trial_time_bin * (timebin.dur.msec / 1000))]


ggplot(regressed.df, aes(x=trial.time.sec, y=cell_order)) +
  geom_point() +
  geom_abline(intercept=-seq.model$coefficients[1], slope = -seq.model$coefficients[2]) +
  scale_y_reverse() +  
  geom_vline(xintercept = min(in.reward.zone.sec), linetype='dashed') +
  gtheme

```


## Plot by distance run
```{r}
cell.order.df = order.cells.by.max.val(trial.traces[timestamp > 35 * 1000, ])
max.moved.dist = ceiling(max(data.traces$moved_distance))
dist.nbins = 100
dist.traces = stimbin.traces(data.traces[trial == selected.trial & timestamp > 35 * 1000, ], 
                             moved_distance, dist.nbins, max.width = max.moved.dist)
binned.dist.traces = dist.traces[, .(mean.norm_deconv_trace = mean(norm_deconv_trace),
                                     mean.norm_trace = mean(norm_trace),
                                     atReward=mean(atReward0 + atReward1)), 
                                 by=.(animal, date, trial, cell_id, bin.moved_distance)]
binned.dist.traces$atReward = as.factor(ifelse(binned.dist.traces$atReward > 0.5, 'at_reward', 'not_at_reward'))

g.raster = binned.dist.traces[bin.moved_distance > 0] %>%
  #filter(trial %in% c(6,7,8)) %>%
  filter(!is.na(bin.moved_distance) ) %>%
  left_join(cell.order.df, by='cell_id') %>% 
  ggplot() +
  geom_tile(aes(x=round(bin.moved_distance * max.moved.dist / dist.nbins), 
                  y=as.integer(cell_order), 
                  fill=mean.norm_deconv_trace,
                  width=5, height=1)) +
  geom_tile(aes(x=round(bin.moved_distance  * max.moved.dist / dist.nbins), y=-2, color=atReward)) +
  xlab('Distance run (cm)') +
  ylab('Cell') +
  gtheme +
  theme(legend.position = 'none') +
  facet_grid(trial ~ .) +
  scale_fill_gradient(low='white', high = 'black') +
  scale_color_manual(values=c('#0098ffff', 'white')) +
  scale_y_reverse()

dist.behav.traces = behav.traces %>%
  dplyr::mutate(trial_time_sec = trial_time_bin * (timebin.dur.msec / 1000)) %>%
  pivot_longer(c(x, y, is_headdip, is_running, trial_time_sec, velocity, total_activity, atReward0, atReward1,  
                 dist_reward0, dist_reward1, angle),
               names_to='metric', values_to='value')
g.dist.behav = dist.behav.traces %>%
  filter(trial==selected.trial) %>%
  #filter(metric %in% c( 'trial_time_sec', 'velocity')) %>%
  filter(metric == 'velocity', value < 50) %>% 
  ggplot(aes(x=moved_distance, y=value)) +
  geom_line() +
  facet_grid(metric ~ ., scales='free_y') +
  xlab('Distance (cm)')
plot_grid(g.raster, g.dist.behav, ncol=1, rel_heights = c(3, 1))

```

Find periods of approach to reward
```{r}
data.traces = as.data.table(data.traces)
data.traces.approach = group_by(data.traces[exp_title == 'trial',], animal, exp_title, trial, cell) %>%
  arrange(trial, cell, timestamp) %>%
  dplyr::mutate(
    rew0.approach.timestamp = reward.approach.timestamp(atReward0, timestamp),
    rew1.approach.timestamp = reward.approach.timestamp(atReward1, timestamp),
    rew0.approach = is.reward.approach(atReward0,
                                       atReward1,
                                       timestamp),
    rew1.approach = is.reward.approach(atReward1,
                                       atReward0,
                                       timestamp)) %>%
  as.data.table()

data.traces.approach %>%
  filter(rew0.approach, cell_id == 0) %>% 
  filter(velocity < 50) %>% 
  ggplot() +
  geom_tile(aes(x=round(-dist_reward0 * perc2dist), y=trial, fill=velocity, width=3)) +
  #geom_tile(aes(x=round(rew1.approach.timestamp), y=trial, fill=velocity, width=100)) +
  scale_fill_gradient(low='grey80', high = 'black') +
  xlab('Distance to reward (cm)') +
  gtheme

data.traces.approach %>%
  filter(rew0.approach, cell_id == 0) %>% 
  filter(velocity < 50) %>% 
  ggplot() +
  geom_tile(aes(x=round(rew0.approach.timestamp), y=trial, fill=velocity, width=100)) +
  scale_fill_gradient(low='grey80', high = 'black') +
  xlab('Time to reward (s)') +
  gtheme


rew0.approach.df = filter(data.traces.approach, rew0.approach) %>%
  filter(velocity < 50) %>%
  dplyr::select(exp_title, trial, timestamp, cell_id, dist_reward0, velocity, norm_deconv_trace) %>%
  dplyr::distinct()

cor(rew0.approach.df$velocity, rew0.approach.df$dist_reward0)

# The cells active at reward are activity anticorrelated with velocitymore than other cells
group_by(rew0.approach.df, exp_title, cell_id) %>%
  dplyr::summarise(cor.df2velocity = cor(velocity, norm_deconv_trace),
                   rew0.weighted.dist = weighted.mean(dist_reward0, norm_deconv_trace)) %>% 
  ggplot() +
  geom_point(aes(x=cor.df2velocity, y=rew0.weighted.dist)) +
  gtheme
```

```{r}
behav.traces %>%
  #filter(trial == 1) %>%
  dplyr::mutate(velocity = velocity / 20000) %>%
  dplyr::mutate(atReward = (atReward0 + atReward1) / 2000) %>%
  dplyr::select(trial, timestamp, velocity, total_activity, atReward) %>%
  tidyr::pivot_longer(c(velocity, total_activity, atReward), names_to='metric', values_to='value') %>%
  ggplot(aes(x=timestamp/1000, metric)) +
  geom_line(aes(y=value)) +
  facet_grid(trial + metric ~ ., space = 'free_y', scales='free_y') +
  #xlim(c(5,200)) +
  gtheme
```
## Principal components of activity plotted vs behavioural variables
```{r}
pca.res = prcomp(deconv_trace.matrix, center = TRUE, scale. = TRUE)
cumvar = cumsum(pca.res$sdev*pca.res$sdev)
cumvar.portion = cumvar / cumvar[length(cumvar)]
npc = which(cumvar.portion >= 0.9) %>% first
response.df = as.data.frame(pca.res$x[,1:npc])
response.df$time_bin = as.integer(rownames(deconv_trace.matrix))
response.df = as.data.table(response.df)
joined.response.df = response.df[behav.traces, on='time_bin']
melt.pc.df = data.table::melt(joined.response.df, id.vars=c('time_bin', 'trial_time_bin', 'trial'))

```

Plot pcs over time
```{r}
melt.pc.df %>%
  filter(variable %in% c('PC1', 'PC2', 'PC3', 'PC4', 'velocity', 'total_activity')) %>%
  filter(trial < 3) %>%
  #filter(variable %in% c('PC1')) %>%
  ggplot() +
  geom_line(aes(x=trial_time_bin, y=value)) +
  facet_grid(trial + variable ~ ., scales='free_y')
```

```{r}
m = lm(log(total_activity) ~ velocity + atReward0 + atReward1 + angle + dist_reward0 + dist_reward1, 
       data=joined.response.df)
       #subset = atReward0 + atReward1 < 0.1)
summary(m)
```
# Cell correlations

For all day
```{r}
source('correlations.R')
C = cor(deconv_trace.matrix)
image(C)
shuffled.cors.df = get.shuffled.cors.df(deconv_trace.matrix, 100)
cors.df = create.cor.values.df(C)
#cors.pvals = test.cors.not.different(shuffled.cors.df, cors.df)
#pval=quantile(cors.pvals, c(0.95))[1]
plot.shuffled.cors(shuffled.cors.df, cors.df)
```

For running epochs vs immobility
```{r}
running.trace.matrix = reshape2::acast(binned.traces[is_running > 0], time_bin ~ cell_id, value.var='norm_deconv_trace')
immobility.trace.matrix = reshape2::acast(binned.traces[is_running == 0], time_bin ~ cell_id, value.var='norm_deconv_trace')
plot.shuffled.cors(create.cor.values.df(cor(immobility.trace.matrix)),
                   create.cor.values.df(cor(running.trace.matrix)), 
                   shuffled.label = 'immobility', original.label='running') +
  gtheme
```
# Cell traces Cross-Correlations
Cross-correlations on a sequence ordered by the max trace value.
This doesn't make sense - after found a sequence, need to keep lags within the sequence.
```{r}
running.trial.trace.matrix = reshape2::acast(binned.traces[is_running > 0 & trial == 1,], 
                                             time_bin ~ cell_id, value.var='norm_deconv_trace')

ncells = ncol(running.trial.trace.matrix)
cell_index_pairs = combn(seq_len(ncells),2)

cell.max.time.i = apply(running.trial.trace.matrix, 2, which.max)
cell.order.df = data.frame(cell_id=cell_ids, 
                           max.time.i=cell.max.time.i) %>%                
  dplyr::arrange(cell.max.time.i) %>%                                                       
  dplyr::mutate(cell_order = dplyr::row_number())

ccov.df = data.frame()
ncells.compared = 1

for (trial_i in unique(binned.traces$trial)) {
  trial.trace.matrix = reshape2::acast(binned.traces[is_running > 0 & trial == trial_i,], 
                                       time_bin ~ cell_id, value.var='norm_deconv_trace')
  for (i in 1:(ncells - 1)) {
    for (j in (i+1):min(ncells, i+ncells.compared)) {
      fst.cell.i = cell.order.df$cell_id[i]
      snd.cell.i = cell.order.df$cell_id[j]
      
      CC = ccf(trial.trace.matrix[,fst.cell.i], 
               trial.trace.matrix[,snd.cell.i], 
               lag.max = 10 * (1000 / timebin.dur.msec),
               type = 'correlation', 
               plot=FALSE)
      
      #max.lag.index = (length(CC$lag) - 1) / 2 + which.max(CC$acf[((length(CC$lag) - 1) / 2) : length(CC$lag)])
      max.lag.index = which.max(CC$acf)
      ccov.df = bind_rows(
        ccov.df, 
        list(fst.cell = colnames(trial.trace.matrix)[fst.cell.i],
             snd.cell = colnames(trial.trace.matrix)[snd.cell.i],
             trial = trial_i,
             lag.sec = CC$lag[max.lag.index] * timebin.dur.msec / 1000,
             ccor = CC$acf[max.lag.index],
             ccor0 = CC$acf[(length(CC$lag) + 1) / 2]))
    }
  }
}

```

```{r}
ccov.df$trial = as.factor(ccov.df$trial)
ggplot(ccov.df, aes(x=lag.sec, y=ccor)) + 
  geom_point(shape=1) +
  geom_smooth() +
  facet_wrap(trial ~ .) +
  geom_vline(xintercept = 0, linetype = 'dashed') +
  gtheme
```

Correlated cells stay correlated acros trials - but that does not prove about the stable sequence
```{r}
ccov.df = dplyr::mutate(ccov.df, cell_pair = paste(fst.cell, snd.cell, sep='x'))
high.cor.trial1.pairs = subset(ccov.df, trial == 1 & ccor0 > 0.4)$cell_pair
ggplot(ccov.df, aes(x=trial, y=ccor0, color=cell_pair %in% high.cor.trial1.pairs)) + 
  geom_violin()
```

# Cross Correlation between velocity and pop activity


Activity preceedes higher velocity by 5 sec for G-BR learning1 day 1
Simultaneous for G-BR learning1 day4 and day5

K-BR - signal preceeding velocity - 
Signal preceeding velocity:
- slowing down at reward when highest activity
- starting to move after a pop event

TODO: left-skewed lag distribution...
look at rew preceeding and rew proceeding epochs separetely
```{r}
population.cors = tibble(trial=integer(), 
                         peak.lag.ms=integer(),
                         peak.cor=numeric(),
                         cor.signif.level=numeric())
for (trial_i in unique(behav.traces$trial)) {
  trial_subset = which(behav.traces$trial == trial_i)
  trace.velocity.ccf = ccf(total.deconv.activity[trial_subset], 
                           behav.traces$velocity[trial_subset], 
                           lag.max=20 * 1000/timebin.dur.msec, 
                           type='correlation', 
                           plot=FALSE)
  signif.level = qnorm((1 + 0.95)/2)/sqrt(trace.velocity.ccf$n.used)
  
  max.acf.i = which.max(trace.velocity.ccf$acf)
  peak.lag.ms = trace.velocity.ccf$lag[max.acf.i] * (timebin.dur.msec)
  
  population.cors = tibble::add_row(population.cors, trial=trial_i, 
                                                  peak.lag.ms=peak.lag.ms,
                                                  peak.cor=trace.velocity.ccf$acf[max.acf.i],
                                                  cor.signif.level=signif.level)
}
```

# Analysis on ccor for all data

Percent of trials with signif corrs
```{r}
all.population.cors %>%
  left_join(trials.meta.df) %>%
  left_join(mouse.meta.df) %>%
  group_by(exp_title, implant) %>%
  dplyr::summarise(cors.signif = mean(peak.cor > cor.signif.level))
```

```{r}
all.population.cors %>%
  filter(peak.cor > cor.signif.level) %>%
  left_join(trials.meta.df) %>%
  left_join(mouse.meta.df) %>%
  group_by(implant, day_desc, exp_title, animal) %>%
  #dplyr::summarise(peak.lag.ms.med=median(peak.lag.ms), peak.cor.med=median(peak.cor)) %>%
  filter(day_desc %in% c('habituation day#3', 'learning1 day#3', 'learning1 day#4', 'learning1 day#5', 'learning2 day#1', 'learning2 day#2')) %>%
  ggplot() +
  geom_point(aes(x=peak.lag.ms, y=peak.cor, color=animal)) +
  facet_grid(animal + implant ~ day_desc) +
  geom_vline(xintercept = 0, linetype='dashed') +
  gtheme +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))
```



Principal components analysis
```{r}
day.pca = prcomp(response.matrix, center = TRUE, scale. = TRUE)

day.pca$x[,1:50] %>% image
```

#NMF
```{r}
library(NMF)

res20 <- nmf(t(response.matrix), 20, seed='nndsvd')
t(coef(res20))[,1:20] %>% image
```

Population activity at reward:

```{r}
source('tracking_info.R')

get_index_arrived = function(at.reward.vec, timestamps) {
  indecies = which(at.reward.vec == 1)
  if (length(indecies) == 0) {
    return(-1)
  }
  return(timestamps[indecies[1]])
}

aligned.data.df = filter(data.traces) %>%
         group_by(trial_id, date, trial, cell) %>%
         # mutate(at_rew0 = is.at.reward(velocity, dist_reward0, timestamp, running.thresh = 2),
         #        at_rew1 = is.at.reward(velocity, dist_reward1, timestamp, running.thresh = 2)) %>%
         mutate(arrived.rew0=get_index_arrived(atReward0, timestamp),
                arrived.rew1=get_index_arrived(atReward1, timestamp),
                timestamp.rew0 = timestamp  - arrived.rew0,
                timestamp.rew1 = timestamp - arrived.rew1) %>%
         ungroup()
```



```{r}
is.within = function(val, range=c(-3000, 20000)) {
  return (val >= range[1] & val <= range[2])
}

trace.at.reward = dplyr::filter(aligned.data.df, is.within(timestamp.rew1)) %>%
  dplyr::rename(timestamp.rew = timestamp.rew1)
```

```{r}
time_bin_sec = 1
pop.mean.at.reward = trace.at.reward %>%
  mutate(timestamp_bin = floor(timestamp.rew / time_bin_sec / 1000)) %>%
  group_by(trial, timestamp_bin) %>%
  dplyr::summarise(trace.mean = mean(trace))
```

```{r}
ggplot(pop.mean.at.reward) +
  geom_raster(aes(x=timestamp_bin, y=trial, fill=trace.mean))
```

