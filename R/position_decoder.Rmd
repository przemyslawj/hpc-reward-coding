---
title: "R Notebook"
output: html_notebook
editor_options: 
  chunk_output_type: inline
---

```{r include=FALSE}
library(dplyr)
library(data.table)
library(datatrace)
library(permute)
library(plotly)

source('distances.R')
source('traces_input.R')
source('locations.R')
source('plotting_params.R')
source('fixed_effects.R')
source('utils.R')
source('position_decoder_utils.R')
```

```{r}
perc2dist = 1.2
goal.cell.max.dist = 20 / perc2dist
#subset.caimg_result_dirs = caimg_result_dirs[shuffle(caimg_result_dirs)[1:5]]
subset.caimg_result_dirs = caimg_result_dirs

mouse.meta.df = read.mouse.meta(rootdirs)
trials.meta.df = read.trials.meta(rootdirs)
all.locations.df = map_dfr(rootdirs, read_locations)
rewards.df =  all.locations.df %>%
  filter(!is_test) %>%
  left_join(mouse.meta.df, by='animal') %>%
  left_join(trials.meta.df, by=c('date', 'animal', 'location_set'))
```



```{r}
nshuffles=30
ncells=30

xybins = 20
nbins = 20
cheeseboard.bin.cm = 120 / xybins

get.max.thr = function(max.fraction=0.25, absolute.min=0.01) {
  function(vals) {  
    max.val = max(c(vals, absolute.min), na.rm = TRUE)
    c( max.val* max.fraction, max.val+1) 
  }
}

get.nvenent.thr = function(min.nevents=0.1) {
  function(vals) { c(min.nevents, max(vals) + 1)}
}

prepare.traces = function(data.traces,
                          binned.var,
                          get.bin.thresholds.fun,
                          filter.running=TRUE,
                          timebin.dur.msec=200) {
  setorder(data.traces, exp_title, trial_id, cell_id, timestamp)
  data.traces = detect.events(data.traces, deconv.threshold=0.1)
  # running speed avg > 4 cm/s in 0.5 s window
  data.traces = add.running.col(data.traces, 3.3, 10)
  data.traces = gauss.smooth.df.var(data.traces, filter.len=20, sigma=4.0)
  data.traces[, `:=` (zscored_deconv_trace = zscore(deconv_trace), 
                      zscored_trace = zscore(trace),
                      zscored_smooth_deconv_trace = zscore(smoothed_deconv_trace)),
              by=.(exp_title, cell_id)]
  
  if (filter.running) {
    data.traces.filtered = data.traces[ x > 0 & y > 0 & is_running, ]
  } else {
    data.traces.filtered = data.traces[x > 0 & y > 0,]
  }
  
  date_str = format(data.traces$date[1])
  animal_name = data.traces$animal[1]

  binned.traces = bin.time.space(data.traces.filtered,
                                 nbins.x = xybins,
                                 nbins.y = xybins,
                                 get.bin.thresholds.fun = get.bin.thresholds.fun,
                                 binned.var=binned.var,
                                 timebin.dur.msec=timebin.dur.msec)
  binned.traces = gauss.smooth.df.var(binned.traces, var='nevents', out.var='smoothed_nevents',
                                      filter.len=5, sigma=1.0)
  
  return(binned.traces)
}


discrete.bayes.spatial.decoder = list(
  predicted.var=quo(bin.xy),
  predictor.var=quo(response_bin),
  nclasses=xybins^2,
  train.fun = create.discrete.bayes,
  predict.fun = bayesmax,
  error.fun=bin.distance.error(xybins, xybins)
)

mfr.bayes.spatial.decoder = list(
  predicted.var=quo(bin.xy),
  predictor.var=quo(smoothed_deconv_trace),
  nclasses=xybins^2,
  train.fun = create.mfr.bayes,
  predict.fun = bayesmax_poisson,
  error.fun=bin.distance.error(xybins, xybins)
)
```

```{r}
eval.decoder.same.day = function(caimg_result_dir, 
                                 decoder.config, 
                                 prepare.vars.fun=NULL,
                                 filter.test.traces.fun=NULL,
                                 min.samples=10,
                                 ncells=30, # If ncells == 0, take all cells
                                 nshuffles=20,
                                 exp_title='trial') {
  
  data.traces = read.data.trace(caimg_result_dir, filter_exp_title = exp_title)
  data.traces$date = rep(char2date(data.traces$date[1]), nrow(data.traces))
  binned.traces = prepare.traces(data.traces, 
                                 binned.var='zscored_trace',
                                 get.bin.thresholds.fun = get.quantiles.fun(c(0.9, 1.0)),
                                 timebin.dur.msec = 200)
  if (nrow(binned.traces) == 0) {
    return(data.frame())
  } 
  
  print('Started evaluating the model')
  if (!is.null(prepare.vars.fun)) {
    binned.traces = prepare.vars.fun(binned.traces)
  }
  cell_ids = binned.traces$cell_id %>% unique
  
  all.shuffles.eval.res = map_dfr(1:nshuffles, function(j) {
    subset.traces = binned.traces
    if (ncells > 0) {
      cell_ids = cell_ids[shuffle(cell_ids)]
      subset.traces = binned.traces[cell_id %in% cell_ids[1:min(ncells, length(cell_ids))],]
    }
    
    eval.df = eval.decoder(subset.traces,
                           nclasses=decoder.config$nclasses,
                           predicted.var=!!decoder.config$predicted.var,
                           error.fun=decoder.config$error.fun,
                           train.fun=decoder.config$train.fun,
                           predict.fun=decoder.config$predict.fun,
                           predictor.var=!!decoder.config$predictor.var,
                           cv=TRUE,
                           min.samples=min.samples,
                           filter.test.traces.fun=filter.test.traces.fun)

    if (nrow(eval.df) > 0) {
      eval.df$animal = binned.traces$animal[1]
      eval.df$date = binned.traces$date[1]
      eval.df$shuffle = j
    }
    eval.df
  })
  
  return(all.shuffles.eval.res)
}


scale.bins2cm = function(decoding.df) {
  decoding.df$error = decoding.df$error * cheeseboard.bin.cm
  if ('random_error' %in% names(decoding.df)) {
    decoding.df$random_error = decoding.df$random_error * cheeseboard.bin.cm
  }
  return(decoding.df)
}

join.meta.dfs = function(df) {
  df = left_join(df, mouse.meta.df, by='animal') %>%
    left_join(trials.meta.df, by=c("animal", "date"))
  df$day_desc = as.factor(df$day_desc)
  return(df)
}

```


# Spatial decoder evaluation
#Evaluate same day during learning
```{r include=FALSE}
eval.parts = list()
shuffle.configs.df = data.frame(ncells=c(0, 60, 30), nshuffles=c(1, 30, 30))

for (caimg_result_dir in habit_caimg_dirs) {
#for (caimg_result_dir in test_caimg_dirs) {
  for (config_i in nrow(shuffle.configs.df)) {
    out.name = paste(caimg_result_dir, config_i, sep='_')
    res.df = eval.decoder.same.day(
      caimg_result_dir, 
      decoder.config=discrete.bayes.spatial.decoder,
      #decoder.config=mfr.bayes.spatial.decoder,
      min.samples=10,
      ncells=shuffle.configs.df$ncells[config_i],
      nshuffles=shuffle.configs.df$nshuffles[config_i])
    res.df$decoder_ncells = shuffle.configs.df$ncells[config_i]
    eval.parts[[out.name]] = res.df
  }
}

spatial.error.df = do.call('rbind', eval.parts)
spatial.error.df = scale.bins2cm(spatial.error.df) %>% join.meta.dfs()
```

Utility functions for summarising and plotting the errors
```{r}
create.error.summary = function(df, ...) {
  grouping.vars = enquos(...)
  df %>%
    group_by(!!!grouping.vars) %>%
    dplyr::summarise(median.error=median(error),
                     sem.error=sem(error),
                     sd.error=sd(error),
                     error.p25=quantile(error, 0.25)[1],
                     error.p20=quantile(error, 0.2)[1],
                     median.random.error=median(random_error),
                     mean(random_error),
                     sem.random.error=sem(random_error)) %>%
    dplyr::mutate(error.fraction = median.error / median.random.error,
                  rand.error.diff = median.random.error - median.error)
}

group.error.summary = function(df, ...) {
  grouping.vars = enquos(...)
  df %>%
    group_by(!!!grouping.vars) %>%
    dplyr::summarise(mean(median.error),
                     sem(median.error),
                     mean(median.random.error),
                     sem(median.random.error))
}

g.eval.animal.summary = function(error.summary) {
  ggplot(error.summary, aes(x=day_desc, y=median.error, group=animal, color=implant)) +
    geom_errorbar(aes(ymin=median.error-sem.error, ymax=median.error+sem.error), width=0.2) +
    gtheme +
    theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
    ylab('Median error (cm)') + xlab('')
}
```

```{r spatial_error}
spatial.error.summary = create.error.summary(spatial.error.df, implant, animal, day_desc, decoder_ncells) 

group.error.summary(
  spatial.error.summary,
  implant)

spatial.error.summary %>%
  g.eval.animal.summary() +
  facet_grid(. ~ decoder_ncells)
```

## Eval the spatial decoder excluding places at the reward
```{r}
bin.size = 100 / nbins
min.rew.dist.thresh = 10
spatial.error.df = spatial.error.df %>%
  group_by(implant, animal, date) %>%
  dplyr::mutate(actual.binx=from_1dim(actual.bin.xy, nbins)$x,
                actual.biny=from_1dim(actual.bin.xy, nbins)$y,
                min.rew.dist=calc.min.rew.dist(filter.rews.df(rewards.df, date[1], animal[1]),
                                               # translate bins to 0-100 coordinates, centre in the middle of the bin
                                               (actual.binx + 0.5) * bin.size,
                                               (actual.biny + 0.5) * bin.size)$rew.dist,
                is.close2rew = min.rew.dist <= min.rew.dist.thresh)
```

```{r}
spatial.error.rewdiff.summary = filter(spatial.error.df, !is.na(is.close2rew)) %>%
  #create.eval.summary(implant, animal, day_desc, is.close2rew) %>%
  create.error.summary(implant, animal, day_desc, is.close2rew) %>%
  dplyr::mutate(close2rew.errorname = ifelse(is.close2rew, 'close2rew.error', 'far2rew.error')) %>%
  reshape2::dcast(implant + animal + day_desc ~ close2rew.errorname, value.var='median.error') %>% 
  dplyr::mutate(median.error.diff = close2rew.error - far2rew.error )
```

Decoding error is lower at reward than further away, but also sampling is lower there, so it's a natural weaker spot of the decoder.
```{r}
ggplot(spatial.error.rewdiff.summary, aes(x=day_desc, y=median.error.diff, group=implant, color=implant)) +
  geom_point(position=position_dodge(width=0.5)) +
  gtheme +
  geom_hline(yintercept = 0, linetype='dashed') +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  ylab('Median error at reward - away from reward (cm)') + xlab('')
```
Is the decoding out of reward constant over days? No, seems a bit better with time.
```{r}
filter(spatial.error.df, !is.close2rew) %>%
  create.error.summary(implant, animal, day_desc) %>%
  g.eval.animal.summary()
```

## Eval beforetest trials
```{r include=FALSE}
eval.parts = list()
for (caimg_result_dir in test_caimg_dirs) {
  for (config_i in nrow(shuffle.configs.df)) {
    out.name = paste(caimg_result_dir, config_i, sep='_')
    res.df = eval.decoder.same.day(
      caimg_result_dir, 
      decoder.config=discrete.bayes.spatial.decoder,
      #decoder.config=mfr.bayes.spatial.decoder,
      min.samples=10,
      ncells=shuffle.configs.df$ncells[config_i],
      nshuffles=shuffle.configs.df$nshuffles[config_i],
      exp_title='beforetest')
    if (nrow(res.df) > 0) {
      res.df$decoder_ncells = shuffle.configs.df$ncells[config_i]
      eval.parts[[out.name]] = res.df
    }
  }
}

beforetest.spatial.error.df = do.call('rbind', eval.parts)
beforetest.spatial.error.df = beforetest.spatial.error.df %>% 
  scale.bins2cm %>%
  join.meta.dfs()
```

```{r}
beforetest.error.summary = create.error.summary(beforetest.spatial.error.df, implant, animal, day_desc)
beforetest.error.summary

beforetest.spatial.error.hist.df = filter(beforetest.spatial.error.df, str_starts(day_desc, 'learning')) %>%
  group_by(implant, animal, day_desc, decoder_ncells) %>%
  dplyr::summarise(create.hist.tibble(error, hist.breaks=seq(0,130,10)), nsamples=n())

beforetest.spatial.error.hist.df %>%
  group_by(implant, decoder_ncells, mid) %>%
  dplyr::summarise(mean.pct.count=mean(pct.count), sem.pct.count=sem(pct.count)) %>%
  ggplot(aes(y=mean.pct.count, x=mid-5, color=implant)) +
  geom_step(position = 'identity', alpha=1.0) +
  geom_errorbar(aes(x=mid, ymin=mean.pct.count-sem.pct.count, ymax=mean.pct.count+sem.pct.count), 
                width=4, size=0.25) +
  ylab('%') + xlab('Error (cm)') +
  scale_color_manual(values=two.colours) +
  facet_grid(. ~ decoder_ncells) +
  gtheme
```

```{r}
compare.decoding.error = function(error.summary) {
  error.model = lmerTest::lmer(#rand.error.diff ~ implant + (1 | animal), 
                               median.error ~ implant * decoder_ncells + (1 | animal), 
                               data=error.summary,
                               REML=TRUE)
  print(summary(error.model))
  print(anova(error.model, refit=FALSE, ddf='Satterthwaite'))
  g = plot.model.diagnostics(error.model, error.summary$animal, error.summary$implant)
  print(g)
  print(lsmeansLT(error.model))
  return(error.model)
}
spatial.error.hist.df = filter(spatial.error.df, str_starts(day_desc, 'habituation')) %>%
  group_by(implant, animal, day_desc, decoder_ncells) %>%
  dplyr::summarise(create.hist.tibble(error, hist.breaks=seq(0,130,10)), nsamples=n()) 

spatial.error.hist.df %>%
  group_by(implant, decoder_ncells, mid) %>%
  dplyr::summarise(mean.pct.count=mean(pct.count), sem.pct.count=sem(pct.count)) %>%
  ggplot(aes(y=mean.pct.count, x=mid-5, color=implant)) +
  geom_step(position = 'identity', alpha=1.0) +
  geom_errorbar(aes(x=mid, ymin=mean.pct.count-sem.pct.count, ymax=mean.pct.count+sem.pct.count), 
                width=4, size=0.25) +
  ylab('%') + xlab('Error (cm)') +
  scale_color_manual(values=main.two.colours) +
  facet_grid(. ~ decoder_ncells) +
  gtheme
ggsave('spatial_decoding_histogram.pdf',
       path='/home/prez/tmp/cheeseboard/', device=cairo_pdf,
       units='cm', width=7.5, height=3.8)

habit.error.summary = filter(spatial.error.summary, str_starts(day_desc, 'habituation')) %>%
  mutate(animal_day_desc = paste(animal, day_desc, sep='_'))
habit.error.summary$decoder_ncells = as.factor(habit.error.summary$decoder_ncells)

multicell.habit.animal_day_desc = 
  as.data.table(place.cell.db)[
    exp=='habituation', 
    .(ncells=.N), 
    by=.(implant, animal, day_desc)][
  ncells >= 30, (animal_day_desc = paste(animal, day_desc, sep='_'))]

random.error.df = habit.error.summary %>% 
  dplyr::ungroup() %>%
  dplyr::summarise(m.random.error = mean(median.random.error), 
                   sem.random.error=sem(median.random.error)) 

g = habit.error.summary %>%
  #filter(animal_day_desc %in% multicell.habit.animal_day_desc) %>%
  ggplot(aes(x=implant, y=median.error, group=implant, color=implant, day=day_desc, animal_name=animal)) +
  stat_summary(fun.data='mean_cl_boot', geom='crossbar') +
  geom_jitter(shape=1, width=0.2, height=0, size=0.5) +
  geom_hline(yintercept = random.error.df$m.random.error[1]-random.error.df$sem.random.error[1]) +
  geom_hline(yintercept = random.error.df$m.random.error[1]+random.error.df$sem.random.error[1]) +
  facet_grid(. ~ decoder_ncells) +
  scale_color_manual(values=main.two.colours) +
  gtheme +
  ylab('Median error (cm)') + xlab('') + ylim(c(0,61))
g
ggsave('spatial_decoding_comparison.pdf', g,
       path='/home/prez/tmp/cheeseboard/', device=cairo_pdf,
       units='cm', width=7.5, height=3.8)

#ggplotly(g)

print('Compare spatial decoder for habituation with ncells=30')
m = compare.decoding.error(filter(habit.error.summary, 
                                  decoder_ncells != 60))
pairwise.post.hoc(m, factor.interaction = 'implant:decoder_ncells')

group.error.summary(habit.error.summary, implant, decoder_ncells)

print('Evidence difference in spatial decoding accuracy on all cells')
models = create.bayes.lm.pair(
  filter(habit.error.summary, decoder_ncells == 0),
  formula.full = median.error ~ 1 + implant + animal,
  formula.null = median.error ~ 1 + animal,
  whichRandom = 'animal')
models$full / models$null
calc.pair.95CI(models$full, show.percent.change = FALSE)

models = create.bayes.lm.pair(
  filter(habit.error.summary, decoder_ncells == 30),
  formula.full = median.error ~ 1 + implant + animal,
  formula.null = median.error ~ 1 + animal,
  whichRandom = 'animal')
print('Insufficient evidence to say if different spatial decoding accuracy on 30 cells')
models$full / models$null
calc.pair.95CI(models$full, show.percent.change = FALSE)
```


## Eval on another day
```{r}
eval.model = function(tested_model, binned.traces, decoder.config) {
    model.visited = which(tested_model$prior > 0)
    binned.traces.filtered = binned.traces[get(quo_name(decoder.config$predicted.var)) %in% model.visited,]
    system.time(eval.res <- eval.testdata2(binned.traces.filtered, 
                                           tested_model, 
                                           predict.fun=decoder.config$predict.fun,
                                           error.fun=decoder.config$error.fun,
                                           predicted.var=!!decoder.config$predicted.var,
                                           nclasses=decoder.config$nclasses,
                                           predictor.var=!!decoder.config$predictor.var))
    if (nrow(eval.res$df) == 0) {
      return(list(df=data.frame()))
    }
    
    random.classifier.res <- eval.testdata2(binned.traces.filtered, 
                                            tested_model, 
                                            predict.fun=random.prior.classifier,
                                            error.fun=decoder.config$error.fun,
                                            predicted.var=!!decoder.config$predicted.var,
                                            nclasses=decoder.config$nclasses,
                                            predictor.var=!!decoder.config$predictor.var)

    eval.res$df$random_error = random.classifier.res$df$error
    eval.res$df$test_date = as.Date(binned.traces$date[1])
    eval.res$df$animal = binned.traces$animal[1]
    return(eval.res)
}
  
train.decoder.model = function(training.traces,
                               decoder.config,
                               filter.training.trace.fun=NULL) {
  if (!is.null(filter.training.trace.fun)) {
    training.traces = filter.training.trace.fun(training.traces)  
  }
  if (nrow(training.traces) == 0) {
    return(NULL)
  }
  model = decoder.config$train.fun(
          training.traces, 
          nclasses=decoder.config$nclasses,
          predictor.var=!!decoder.config$predictor.var,
          predicted.var=!!decoder.config$predicted.var)
  
  model$model_dates = unique(training.traces$date)
  return(model)
}

# Evaluates the decoders against the test data in caimg_result_dir, create and append a model for the current dir
eval.decoder.other.day = function(caimg_result_dir, 
                                  decoder.config,
                                  trials.meta.df,
                                  models,
                                  prepare.vars.fun=NULL,
                                  filter.training.trace.fun=NULL,
                                  filter.test.traces.fun=NULL,
                                  exp_title='trial',
                                  max.days.diff=2,
                                  min.days.diff=1,
                                  min.samples=10,
                                  binned.varname='zscored_trace',
                                  nshuffles=1,
                                  ncells=0) {
  data.traces = read.data.trace(caimg_result_dir, filter_exp_title = exp_title)
  data.traces$date = rep(char2date(data.traces$date[1]), nrow(data.traces))
  date_str = format(char2date(data.traces$date[1]))
  animal_name = data.traces$animal[1]
  
  eval.dfs = data.frame()
  binned.traces = prepare.traces(data.traces,
                                 filter.running=TRUE,
                                 timebin.dur.msec = 200,
                                 #get.bin.thresholds.fun = get.nvenent.thr(0.1),
                                 get.bin.thresholds.fun = get.quantiles.fun(c(0.9, 1.0)),
                                 binned.var=binned.varname)
  
  if (!is.null(prepare.vars.fun)) {
    binned.traces = prepare.vars.fun(binned.traces)
  }
  
  for (model_date in names(models[[animal_name]])) {
    model.date.ordinal = filter(trials.meta.df, animal==animal_name, date==model_date) %>% pull(exp_day_ordinal)
    test.date.ordinal = filter(trials.meta.df, animal==animal_name, date==date_str) %>% pull(exp_day_ordinal)
    exp.days.diff = test.date.ordinal - model.date.ordinal
    if (exp.days.diff <= max.days.diff && exp.days.diff >= min.days.diff) {
        tested_model = models[[animal_name]][[model_date]]
        model.cell_ids = as.integer(colnames(tested_model$likelihood))
        cell_ids = intersect(unique(binned.traces$cell_id), model.cell_ids)
        if (length(cell_ids) < 5) {
          warning('Few overlapping cells (', length(cell_ids), ') for animal=', animal_name, 
                  ' between day=', format(model_date), ' and day=', date_str)
          next
        }
        test.traces = binned.traces
        if (!is.null(filter.test.traces.fun)) {
           test.traces = filter.test.traces.fun(test.traces, model_date)
        }
        for (shuffle_i in 1:nshuffles) {
          shuffle_cell_ids = cell_ids
          if (ncells > 0) {
            shuffle_cell_ids = shuffle(cell_ids)[1:min(ncells, length(cell_ids))]
          }
          subset.model = tested_model
          subset.model$likelihood = tested_model$likelihood[, which(model.cell_ids %in% cell_ids),]
          eval.res = eval.model(subset.model, binned.traces[cell_id %in% cell_ids], decoder.config)
          eval.res$df$model_date = char2date(model_date)
          eval.res$df$shuffle_i = shuffle_i
          eval.dfs = bind_rows(eval.dfs, eval.res$df)
        }
    }
  }
  
  filtered.dfs = filter.sampled.during.training(binned.traces, binned.traces[1,], min.samples=min.samples)
  model = train.decoder.model(filtered.dfs$train, decoder.config, filter.training.trace.fun=filter.training.trace.fun)
  models[[animal_name]][[date_str]] = model
  return(list(df=eval.dfs, models=models))
}

```

```{r include=FALSE}
otherday.decoding.df = data.frame()
models = list()
#sample.caimg_result_dirs = c(caimg_result_dirs[1:5], caimg_result_dirs[50:55])

for (caimg_result_dir in caimg_result_dirs) {
  eval.res = eval.decoder.other.day(caimg_result_dir, 
                                    discrete.bayes.spatial.decoder,
                                    trials.meta.df,
                                    models,
                                    binned.varname = 'zscored_trace')
  models = eval.res$models
  otherday.decoding.df = bind_rows(otherday.decoding.df, eval.res$df)
}

otherday.decoding.df = scale.bins2cm(otherday.decoding.df) %>% 
  left_join(mouse.meta.df, by='animal') %>%
  left_join(trials.meta.df, by=c('animal', 'test_date'='date'), suffix=c('', '.test')) %>%
  left_join(trials.meta.df, by=c('animal', 'model_date'='date'), suffix=c('', '.model'))
```

```{r}
otherday.decoding.df = data.table(otherday.decoding.df)

data.table(otherday.decoding.df)[abs(exp_day_ordinal-exp_day_ordinal.model)==1 & location_set == location_set.model,
                                 .(med.error=median(error), med.random.error=median(random_error), .N), 
                                 by=c('implant','animal', 'day_desc.model')][,
                                   .(median(med.error), sem(med.error), median(med.random.error)), by=c('implant', 'day_desc.model')]

data.table(otherday.decoding.df)[abs(exp_day_ordinal-exp_day_ordinal.model)==1 & location_set == location_set.model,
                                 .(med.error=median(error), med.random.error=median(random_error), .N), 
                                 by=c('implant','animal', 'day_desc.model')][,
                                   .(median(med.error), sem(med.error), median(med.random.error)), by=c('implant')]

```

Plot of decoding summary
```{r}
otherday.eval.summary = otherday.decoding.df %>%
  filter(abs(exp_day_ordinal-exp_day_ordinal.model)==1) %>%
  group_by(implant, day_desc.model, animal) %>%
  dplyr::summarise(mean.error=mean(error),
                   median.error=median(error),
                   sd.error=sd(error),
                   sem.error=sem(error),
                   median.random.error=median(random_error))

ggplot(otherday.eval.summary, aes(x=day_desc.model, y=median.error, group=animal, color=implant)) +
  #geom_point() +
  geom_errorbar(aes(ymin=median.error-sem.error, ymax=median.error+sem.error), width=0.2) +
  geom_point(aes(y=median.random.error), color='black') +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  ylab('Median error (cm)') + xlab('Trained day')
```

### Beforetest spatial decoding on other day
```{r include=FALSE}
beforetest.otherday.spatial.decoding.df = data.frame()
models = list()
for (caimg_result_dir in test_caimg_dirs) {
  eval.res = eval.decoder.other.day(caimg_result_dir, 
                                    discrete.bayes.spatial.decoder,
                                    trials.meta.df,
                                    models,
                                    #filter.training.trace.fun = filter.beforetest.pcs,
                                    max.days.diff = 6,
                                    min.days.diff = 4,
                                    binned.varname = 'zscored_trace',
                                    ncells = ncells,
                                    nshuffles = nshuffles)
  models = eval.res$models
  beforetest.otherday.spatial.decoding.df = bind_rows(beforetest.otherday.spatial.decoding.df, eval.res$df)
}

beforetest.otherday.spatial.decoding.df = beforetest.otherday.spatial.decoding.df %>%
  scale.bins2cm() %>% 
  left_join(mouse.meta.df, by='animal') %>%
  left_join(trials.meta.df, by=c('animal', 'test_date'='date'), suffix=c('', '.test')) %>%
  left_join(trials.meta.df, by=c('animal', 'model_date'='date'), suffix=c('', '.model'))
```

```{r}
create.error.summary(beforetest.otherday.spatial.decoding.df, implant, animal, day_desc) %>%
  group.error.summary(implant)
```

### Beforetest spatial decoding on leave-one-out day data - only consider 3 learnings

```{r include=FALSE}
beforetest.onedayout.spatial = eval.decoder.all.other.days(discrete.bayes.spatial.decoder, 
                                                           test.days.df,
                                                           equal.prior = TRUE,
                                                           ncells = ncells,
                                                           nshuffles = nshuffles)
```

```{r}
beforetest.onedayout.spatial %>%
  left_join(mouse.meta.df) %>%
  scale.bins2cm() %>%
  create.error.summary(implant, animal) %>% 
  group.error.summary(implant)
```


## Prediction error at reward
```{r}
rewards.df = data.table(rewards.df)
setkey(rewards.df, date, animal)

min.rew.dist = function(day, animal_name, bin.xy) {
  rews = rewards.df[date==day & animal == animal_name, ]
  if (nrow(rews)==0) {
    return(list(location.ordinal=0, rew.dist=NA))
  }
  trans.xy = from_1dim(bin.xy, nbins)
  bin.size = 100 / nbins
  trans.xy$x = trans.xy$x * bin.size
  trans.xy$y = trans.xy$y * bin.size
  
  dist1 = norm2(rews$trans_x[1] - trans.xy$x, rews$trans_y[1] - trans.xy$y)
  dist2 = norm2(rews$trans_x[2] - trans.xy$x, rews$trans_y[2] - trans.xy$y)
  min.i = as.integer(dist2 < dist1) + 1
  return(list(location.ordinal=rews$location_ordinal[min.i],
              rew.dist=ifelse(min.i==1, dist1, dist2)))
}

short.decoding.df = spatial.error.df %>%
  group_by(date, day_desc, implant, animal) %>%
  dplyr::mutate(actual.rew.dist=min.rew.dist(date[1], animal[1], actual.bin.xy)$rew.dist,
                actual.rew.ordinal=min.rew.dist(date[1], animal[1], actual.bin.xy)$location.ordinal,
                pred.rew.dist=min.rew.dist(date[1], animal[1], bin.xy)$rew.dist,
                pred.rew.ordinal=min.rew.dist(date[1], animal[1], bin.xy)$location.ordinal)
```
Higer error at the reward- maybe doesn't disambiguate
```{r}
short.decoding.df %>%
  filter(actual.rew.dist <= goal.cell.max.dist) %>%
  ggplot() +
  #geom_point(aes(x=actual.rew.dist / 5, y=error), alpha=0.1) +
  geom_violin(aes(x=day_desc, y=error)) +
  facet_grid(. ~ implant) +
  gtheme +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  labs(x='', y='Decoding error (cm)')
```

For the locations at reward, how many were predicted to be at the other reward?
vCA1 encoding 50 % times incorrect on learning1 day#4 and day#5

```{r}
short.decoding.df %>%
  filter(actual.rew.dist <= goal.cell.max.dist) %>%
  left_join(trials.meta.df) %>%
  left_join(mouse.meta.df) %>%
  dplyr::mutate(wrong.rew.loc = (actual.rew.ordinal != pred.rew.ordinal) & (pred.rew.dist <= 25),
                correct.rew.loc = actual.rew.ordinal == pred.rew.ordinal) %>%
  group_by(implant, animal, day_desc) %>%
  dplyr::summarise(pct.wrong.rew=sum(wrong.rew.loc)/n(),
                   pct.correct.rew=sum(correct.rew.loc)/n()) %>%
  ggplot() +
  geom_point(aes(x=day_desc, y=pct.wrong.rew, color='incorrect rew')) +
  geom_point(aes(x=day_desc, y=pct.correct.rew, color='correct rew')) +
  facet_grid(. ~ implant) +
  geom_hline(yintercept=0.5, linetype='dashed') +
  gtheme +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  ylab('Decoding accuracy')
```

# At reward Decoder

## Eval for same day learning and habituation
```{r include=FALSE}
bayes.atreward.decoder.config = list(
  predicted.var = quo(close2rew),
  predictor.var = quo(response_bin),
  nclasses = 2,
  train.fun = create.discrete.bayes,
  predict.fun = bayesmax,
  error.fun = function(x,y) {abs(x-y)}
)

add.close2rew.fun = function(min.rew.dist.thresh) {
  function(data.trace) {
    data.trace[, close2rew := as.integer((dist_reward0 <= min.rew.dist.thresh | dist_reward1 <= min.rew.dist.thresh)) + 1]  
  }
}
```

```{r}
eval.parts = lapply(learning_caimg_dirs, 
                    eval.decoder.same.day, 
                    decoder.config=bayes.atreward.decoder.config,
                    prepare.vars.fun=add.close2rew.fun(min.rew.dist.thresh),
                    min.samples=10,
                    ncells=ncells,
                    nshuffles=nshuffles)

close2rew.decoding.df = do.call('rbind', eval.parts) %>%
  join.meta.dfs()
```

```{r}
data.table(close2rew.decoding.df)[,.(incorrect.pct=mean(error), baseline.pct=mean(random_error)), by=c('animal','day_desc', 'implant')][,.(incorrect.pct=median(incorrect.pct), random.error.pct=median(baseline.pct)), by=c('implant', 'day_desc')]
data.table(close2rew.decoding.df)[day_desc=='learning1 day#5',.(incorrect.pct=mean(error), baseline.pct=mean(random_error)), by=c('implant','animal', 'day_desc')][,.(incorrect=median(incorrect.pct), em=sem(incorrect.pct), random=median(baseline.pct)), by='implant']
```

```{r}
eval.summary = close2rew.decoding.df %>%
  group_by(date, implant, day_desc, animal) %>%
  dplyr::summarise(incorrect.pct=mean(error),
                   random.pct=mean(random_error))

ggplot(eval.summary, aes(x=day_desc, group=implant, color=implant)) +
  geom_point(aes(y=(1-incorrect.pct) * 100), position = position_dodge(width = 0.5)) +
  #geom_point(aes(y=(1-random.pct) * 100), position = position_dodge(width = 0.5), shape=23) +
  gtheme +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  ylab('Decoding accuracy') + xlab('')
```

## Eval beforetest trials
```{r include=FALSE}
mfr.bayes.atreward.decoder.config = list(
  predicted.var = quo(close2rew),
  predictor.var = quo(smoothed_deconv_trace),
  nclasses = 2,
  train.fun = create.mfr.bayes,
  predict.fun = bayesmax_poisson,
  error.fun = function(x,y) {abs(x-y)}
)
```

```{r include=FALSE}
eval.parts = list()
for (caimg_result_dir in test_caimg_dirs) {
  eval.parts[[caimg_result_dir]] = eval.decoder.same.day(
    caimg_result_dir, 
    decoder.config=bayes.atreward.decoder.config,
    #decoder.config=mfr.bayes.atreward.decoder.config,
    prepare.vars.fun=add.close2rew.fun(min.rew.dist.thresh),
    min.samples=5,
    ncells=ncells,
    nshuffles=nshuffles,
    exp_title='beforetest')
}

beforetest.close2rew.df = do.call('rbind', eval.parts)
beforetest.close2rew.df = beforetest.close2rew.df %>% 
  join.meta.dfs()
```

```{r}
beforetest.close2rew.df %>%
  group_by(implant) %>%
  dplyr::summarise(mean(error), sem(error), mean(random_error))

data.table(beforetest.close2rew.df)[,.(incorrect.pct=mean(error), baseline.pct=mean(random_error)), by=c('animal','day_desc', 'implant')][,.(incorrect.pct=median(incorrect.pct), random.error.pct=median(baseline.pct)), by=c('implant', 'day_desc')]
```


## Eval reward decoder on another day for beforetest trials
```{r echo=FALSE}
# beforetest.peaks.at.current.rew = as.data.table(beforetest.peaks.at.current.rew)
# filter.beforetest.pcs = function(binned.trace) {
#   beforetest_date = binned.trace$date[1]
#   place_cell_ids = beforetest.peaks.at.current.rew[date == beforetest_date & 
#                                                      animal == binned.trace$animal[1] & 
#                                                      signif.si,
#                                                    (cell_id)]
#   binned.trace[cell_id %in% place_cell_ids, ]
# }

otherday.rew.decoding.df = data.frame()
models = list()
for (caimg_result_dir in test_caimg_dirs) {
  eval.res = eval.decoder.other.day(caimg_result_dir, 
                                    bayes.atreward.decoder.config,
                                    trials.meta.df,
                                    models,
                                    prepare.vars.fun=add.close2rew.fun(min.rew.dist.thresh), 
                                    max.days.diff = 6,
                                    min.days.diff = 4,
                                    #filter.training.trace.fun = filter.beforetest.pcs,
                                    filter.training.trace.fun = NULL,
                                    binned.varname = 'zscored_trace',
                                    ncells = 30,
                                    nshuffles = 30)
  models = eval.res$models
  otherday.rew.decoding.df = bind_rows(otherday.rew.decoding.df, eval.res$df)
}
otherday.rew.decoding.df = otherday.rew.decoding.df %>%
  left_join(mouse.meta.df, by='animal') %>%
  left_join(trials.meta.df, by=c('animal'='animal', 'model_date'='date'), suffix=c('', '.model')) %>%
  left_join(trials.meta.df, by=c('animal'='animal', 'test_date'='date'), suffix=c('', '.test'))
```


```{r}
otherday.rew.decoding.summary = otherday.rew.decoding.df %>%
  filter(abs(exp_day_ordinal - exp_day_ordinal.test) >= 4) %>%
  group_by(animal, implant, day_desc.test, day_desc) %>%
  dplyr::summarise(incorrect.pct=mean(error),
                   random.pct=mean(random_error),
                   incorrect.random.diff = random.pct-incorrect.pct) 

otherday.rew.decoding.summary %>%
  group_by(implant) %>%
  dplyr::summarise(mean(incorrect.pct), 
                   sem(incorrect.pct),
                   mean(random.pct),
                   sem(random.pct),
                   n=n()) %>%
  dplyr::mutate_if(is.double, scales::percent, 1)
```

### Beforetest reward decoding on leave-one-out day data - only consider 3 learnings
```{r include=FALSE}
test.rewards.df = all.locations.df %>%
  filter(is_test, exp_title=='beforetest') %>%
  left_join(mouse.meta.df, by='animal') %>%
  left_join(dplyr::select(trials.meta.df, -location_set), by=c('date', 'animal'))

# Returns test.rewards DF present on 2 dates
rew.present.both.tests = function(rewards.dates.df) {
  # loc ordinal for reward present on both days
  reward.loc_ord = rewards.dates.df %>%
    count(location_ordinal) %>% filter(n==2) %>% pull(location_ordinal)

  filter(rewards.dates.df, location_ordinal %in% reward.loc_ord ) %>%
    dplyr::select(location_ordinal, trans_x, trans_y) %>%
    dplyr::distinct()
}

# Returns test.rewards of the that not exclude the given rewards DF
exclude.loc.ordinals = function(animal.rews.df, excluded.rews.df) {
  rewards.loc_ords = pull(animal.rews.df, location_ordinal)
  included.reward.loc_ord = setdiff(rewards.loc_ords, pull(excluded.rews.df, location_ordinal))
  
  filter(animal.rews.df, location_ordinal %in% included.reward.loc_ord) %>%
    dplyr::select(location_ordinal, trans_x, trans_y) %>%
    dplyr::distinct()
}

# Filters test.traces to epochs at the tested reward location that was not present during training data and vice-verse
filter.at.present.or.future.rew = function(test.traces, train.traces,
                                           filter.dist.thresh=15/perc2dist) {
  animal.test.rewards.df = filter(test.rewards.df, animal == test.traces$animal[1]) 
  training.rewards.df = filter(animal.test.rewards.df, date %in% unique(train.traces$date)) 
  
  tested.locs.df = bind_rows(rew.present.both.tests(training.rewards.df),
                             exclude.loc.ordinals(filter(animal.test.rewards.df, date == test.traces$date[1]), 
                                                  training.rewards.df)) %>%
    dplyr::distinct()
  
  x = test.traces[, dist.rews := calc.min.rew.dist(tested.locs.df, x, y)$rew.dist]
  x[dist.rews <= filter.dist.thresh, ]
}

# Filters train.traces to epochs at the tested reward location that was not present during training data and vice-verse
filter.train.present.or.future.rew = function(test.traces, train.traces,
                                              filter.dist.thresh=15/perc2dist) {
  animal.test.rewards.df = filter(test.rewards.df, animal == test.traces$animal[1]) 
  training.rewards.df = filter(animal.test.rewards.df, date %in% unique(train.traces$date)) 
  
  tested.locs.df = bind_rows(rew.present.both.tests(training.rewards.df),
                             exclude.loc.ordinals(animal.test.rewards.df, training.rewards.df)) %>%
    dplyr::distinct()
  
  x = train.traces[, dist.rews := calc.min.rew.dist(tested.locs.df, x, y)$rew.dist]
  x[dist.rews <= filter.dist.thresh, ]
}
```

## Other day reward decoding
```{r}
filter.test.samerew.fun = function(test.traces, train.date,
                                   filter.dist.thresh=15/perc2dist) {
  animal.test.rewards.df = filter(test.rewards.df, animal == test.traces$animal[1]) 
  data.rewards.df = filter(animal.test.rewards.df, date %in% c(train.date, test.traces$date[1]))
  
  tested.locs.df = bind_rows(rew.present.both.tests(data.rewards.df),
                             exclude.loc.ordinals(animal.test.rewards.df, data.rewards.df)) %>%
    dplyr::distinct()

  x = test.traces[, dist.rews := calc.min.rew.dist(tested.locs.df, x, y)$rew.dist]
  x[dist.rews <= filter.dist.thresh, ]
}

beforetest.otherday.reward.decoding.df = data.frame()
models = list()
for (caimg_result_dir in test_caimg_dirs) {
  eval.res = eval.decoder.other.day(
    caimg_result_dir, 
    bayes.atreward.decoder.config,
    trials.meta.df,
    models,
    prepare.vars.fun = add.close2rew.fun(goal.cell.max.dist),
    filter.training.trace.fun = function(binned.traces) {
            binned.traces[pmin(dist_reward0, dist_reward1) <= 15/perc2dist | pmin(dist_reward0, dist_reward1) >= 40 / perc2dist, ]
    },
    filter.test.traces.fun = filter.test.samerew.fun,
    max.days.diff = 2,
    min.days.diff = 2,
    binned.varname = 'zscored_trace',
    nshuffles = 0)
  models = eval.res$models
  beforetest.otherday.reward.decoding.df = bind_rows(beforetest.otherday.reward.decoding.df, eval.res$df)
}
```

```{r}
beforetest.otherday.reward.decoding.summary = beforetest.otherday.reward.decoding.df %>%
  left_join(mouse.meta.df) %>%
  left_join(trials.meta.df, by=c('animal'='animal', 'test_date'='date')) %>%
  group_by(implant, animal, test_date) %>%
  dplyr::summarise(mean.error=mean(error), sem.error=sem(error), 
                   mean.rand.error=mean(random_error), sem.rand.error=sem(random_error)) %>%  
  dplyr::mutate(mean.rand.diff=mean.rand.error-mean.error)

beforetest.otherday.reward.decoding.summary %>% 
  group_by(implant) %>%
  dplyr::summarise(mean(mean.error), sem(mean.error), 
                   mean(mean.rand.diff), sem(mean.rand.diff),
                   mean(mean.rand.error), sem(mean.rand.error))
```


## Cross validation
```{r, include=FALSE}
filter.test.samerew.fun = function(test.traces,
                                   filter.dist.thresh=15/perc2dist) {
  animal.test.rewards.df = filter(test.rewards.df, animal == test.traces$animal[1]) 
  test.traces.dates = unique(test.traces$date)
  data.rewards.df = filter(animal.test.rewards.df, date %in% test.traces.dates)
  
  tested.locs.df = bind_rows(rew.present.both.tests(data.rewards.df),
                             exclude.loc.ordinals(animal.test.rewards.df, data.rewards.df)) %>%
    dplyr::distinct()

  x = test.traces[, dist.rews := calc.min.rew.dist(tested.locs.df, x, y)$rew.dist]
  x[dist.rews <= filter.dist.thresh, ]
}

beforetest.onedayout.reward.cv = eval.decoder.all.other.days(
  bayes.atreward.decoder.config, 
  test.days.df,
  equal.prior = TRUE,
  prepare.vars.fun = add.close2rew.fun(goal.cell.max.dist),
  filter.train.traces.fun = function(binned.traces) {
    binned.traces[pmin(dist_reward0, dist_reward1) <= 15/perc2dist | pmin(dist_reward0, dist_reward1) >= 40 / perc2dist, ]
  },
  filter.test.traces.fun = filter.test.samerew.fun,
  min.ncells.for.eval = 10,
  min.present.times = 3,
  test.day.indecies=c(1,3),
  traces.decode.fun=crosseval.decoder.on.paired.days)
```

```{r}
beforetest.onedayout.reward.cv.summary = beforetest.onedayout.reward.cv %>%
  left_join(mouse.meta.df) %>%
  group_by(implant, animal, model_date) %>%
  dplyr::summarise(mean.error=mean(error), sem.error=sem(error), 
                   mean.rand.error=mean(random_error), sem.rand.error=sem(random_error),
                   n=n()) %>%  
  filter(n>=10) %>%
  dplyr::mutate(mean.rand.diff=mean.rand.error-mean.error)
beforetest.onedayout.reward.cv.summary %>% 
  group_by(implant) %>%
  dplyr::summarise(mean(mean.error), sem(mean.error), 
                   mean(mean.rand.diff), sem(mean.rand.diff),
                   mean(mean.rand.error), sem(mean.rand.error))

ggplot(beforetest.onedayout.reward.cv.summary,
           aes(x=implant, y=100*mean.rand.diff, color=implant)) +
  stat_summary(fun.data='mean_cl_boot', geom='crossbar') +
  geom_jitter(shape=1, height=0, width=0.15, size=0.5) +
  geom_hline(yintercept = 0, linetype='dashed') +
  scale_color_manual(values=main.two.colours) +
  gtheme +
  theme(legend.position = 'none') +
  xlab('') + ylab('Accuracy above random (%)') + 
  scale_y_continuous(limits=c(-50,55), breaks=seq(-50,50,25))
```


##Decoder evaluated on training data
```{r include=FALSE}
beforetest.onedayout.reward.training = eval.decoder.all.other.days(
  bayes.atreward.decoder.config, 
  test.days.df,
  equal.prior = TRUE,
  prepare.vars.fun = add.close2rew.fun(goal.cell.max.dist),
  filter.train.traces.fun = function(binned.traces) {
    binned.traces[pmin(dist_reward0, dist_reward1) <= 15/perc2dist | pmin(dist_reward0, dist_reward1) >= 40 / perc2dist, ]
  },
  filter.test.traces.fun = filter.train.present.or.future.rew,
  min.ncells.for.eval = 10,
  min.present.times = 3,
  test.day.indecies=c(1,3))

beforetest.onedayout.reward.training.summary = beforetest.onedayout.reward.training %>%
  left_join(mouse.meta.df) %>%
  group_by(implant, animal, test_date) %>%
  dplyr::summarise(mean.error=mean(error), sem.error=sem(error), 
                   mean.rand.error=mean(random_error), sem.rand.error=sem(random_error)) %>%  
  dplyr::mutate(mean.rand.diff=mean.rand.error-mean.error)
beforetest.onedayout.reward.training.summary %>% 
  group_by(implant) %>%
  dplyr::summarise(mean(mean.error), sem(mean.error), 
                   mean(mean.rand.diff), sem(mean.rand.diff),
                   mean(mean.rand.error), sem(mean.rand.error))
```


##Decoder evaluated on test data
```{r include=FALSE}
beforetest.onedayout.reward = eval.decoder.all.other.days(
  bayes.atreward.decoder.config, 
  test.days.df,
  #ncells = 0,
  #nshuffles = 1,
  equal.prior = TRUE,
  prepare.vars.fun = add.close2rew.fun(goal.cell.max.dist),
  filter.train.traces.fun = function(binned.traces) {
    binned.traces[pmin(dist_reward0, dist_reward1) <= 15/perc2dist | pmin(dist_reward0, dist_reward1) >= 40 / perc2dist, ]
  },
  filter.test.traces.fun = filter.at.present.or.future.rew,
  min.ncells.for.eval = 10,
  min.present.times = 3,
  test.day.indecies=c(1,3))
```



```{r}
beforetest.onedayout.reward.summary = beforetest.onedayout.reward %>%
  left_join(mouse.meta.df) %>%
  left_join(trials.meta.df, by=c('animal'='animal', 'test_date'='date')) %>%
  group_by(implant, animal, test_date) %>%
  dplyr::summarise(mean.error=mean(error), sem.error=sem(error), 
                   mean.rand.error=mean(random_error), sem.rand.error=sem(random_error)) %>%  
  dplyr::mutate(mean.rand.diff=mean.rand.error-mean.error)
  
beforetest.onedayout.reward.summary %>% 
  group_by(implant) %>%
  dplyr::summarise(mean(mean.error), sem(mean.error), 
                   mean(mean.rand.diff), sem(mean.rand.diff),
                   mean(mean.rand.error), sem(mean.rand.error))
```

```{r}
g = ggplot(beforetest.onedayout.reward.summary,
           aes(x=implant, y=100*mean.rand.diff, color=implant)) +
           #aes(x=implant, y=100*mean.rand.diff, color=implant, text=animal, test_day=test_date)) +
  stat_summary(fun.data='mean_cl_boot', geom='crossbar') +
  geom_jitter(shape=1, height=0, width=0.15, size=0.5) +
  geom_hline(yintercept = 0, linetype='dashed') +
  scale_color_manual(values=main.two.colours) +
  gtheme +
  theme(legend.position = 'none') +
  xlab('') + ylab('Accuracy above random (%)') + ylim(c(-50,50))
ggsave('at_rew_classifier.pdf', g, device=cairo_pdf,
       path='/home/prez/tmp/cheeseboard/', units='cm', width=3.0, height=3.2)
ggplotly(g)
g = ggplot(beforetest.onedayout.reward.summary, aes(text=animal, test_day=test_date)) +
  geom_jitter(aes(x=implant, y=100-100*mean.error), shape=1, height=0, width=0.15) +
  geom_hline(yintercept = 50, linetype='dashed') +
  gtheme +
  xlab('') + ylab('Accuracy (%)') + ylim(c(0,100))
ggplotly(g)
# beforetest.onedayout.reward.summary.long = beforetest.onedayout.reward.summary %>%
#   dplyr::select(-sem.error, -mean.rand.diff) %>%
#   tidyr::pivot_longer(c(mean.error, mean.rand.error), names_to='err.type', values_to='err')

m = lmer.test.print(
  beforetest.onedayout.reward.summary,
  var=mean.rand.diff,
  fixed.effects = implant,
  randef.str = '(1 | animal)',
  diagnostics.groupvar = implant)
#lsmeansLT(m)
#lsmeansLT(m, pairwise=T)
```
Bayes factors
```{r}
models = create.bayes.lm.pair(beforetest.onedayout.reward.summary,
                     formula.full = mean.rand.diff ~ 1 + implant + animal,
                     formula.null = mean.rand.diff ~ 1 + animal,
                     whichRandom = 'animal',
                     iterations = 100000)
models$full / models$null
calc.pair.95CI(models$full, show.percent.change = FALSE)
```


```{r include=FALSE}
beforetest.onedayout.loc = eval.decoder.all.other.days(discrete.bayes.spatial.decoder, 
                                                          test.days.df,
                                                          ncells = 0,
                                                          nshuffles = 1,
                                                          equal.prior = TRUE,
                                                          prepare.vars.fun = NULL,
                                                          #filter.test.traces.fun = filter.at.present.or.future.rew,
                                                          test.day.indecies=c(1,3))
```

```{r}
beforetest.onedayout.loc.summary = beforetest.onedayout.loc %>%
  scale.bins2cm() %>%
  left_join(mouse.meta.df) %>%
  left_join(trials.meta.df, by=c('animal'='animal', 'test_date'='date')) %>%
  group_by(implant, animal, test_date) %>%
  dplyr::summarise(mean.error=mean(error),
                   median.error=median(error),
                   sem.error=sem(error), 
                   median.rand.error=median(random_error)) %>%
  dplyr::mutate(median.rand.diff=median.rand.error-median.error) 

beforetest.onedayout.loc.summary %>%
  group_by(implant) %>%
  dplyr::summarise(mean(median.error), sem(mean.error), mean(median.rand.error), mean(median.rand.diff))

m = lmer.test.print(
  beforetest.onedayout.loc.summary,
  var=median.error,
  fixed.effects = implant,
  randef.str = '(1 | animal)',
  diagnostics.groupvar = implant)

ggplot(beforetest.onedayout.loc.summary, aes(text=animal, test_day=test_date)) +
  geom_jitter(aes(x=implant, y=median.error, color=implant),
              shape=1, height=0, width=0.15, size=0.5) +
  geom_hline(yintercept = 57, linetype='dashed') +
  scale_color_manual(values=main.two.colours) +
  gtheme +
  theme(legend.position = 'none') +
  xlab('') + ylab('Median error (cm)') + ylim(c(0, 60))
ggsave('spatial_decoder_other_day.pdf', device=cairo_pdf,
       path='/home/prez/tmp/cheeseboard/', units='cm', width=3.0, height=3.2)

beforetest.onedayout.loc.hist.df = beforetest.onedayout.loc %>%
  scale.bins2cm() %>%
  left_join(mouse.meta.df) %>%
  group_by(implant, animal, test_date) %>%
  dplyr::summarise(create.hist.tibble(error, hist.breaks=seq(0,130,10)), nsamples=n()) 

beforetest.onedayout.loc.hist.df %>%
  group_by(implant, mid) %>%
  dplyr::summarise(mean.pct.count=mean(pct.count), sem.pct.count=sem(pct.count)) %>%
  ggplot(aes(y=mean.pct.count, x=mid-5, color=implant)) +
  geom_step(position = 'identity', alpha=1.0) +
  geom_errorbar(aes(x=mid, ymin=mean.pct.count-sem.pct.count, ymax=mean.pct.count+sem.pct.count), 
                width=4, size=0.25) +
  ylab('%') + xlab('Error (cm)') + labs(colour='') +
  scale_color_manual(values=main.two.colours) +
  gtheme +
  theme(legend.position='top')
ggsave('spatial_decoder_other_day_hist.pdf', device=cairo_pdf,
       path='/home/prez/tmp/cheeseboard/', units='cm', width=3.0, height=4.3)
```

# Decoding if at reward on other beforetest day from mean population activity
```{r include=FALSE}
min.rew.dist.thresh = goal.cell.max.dist

beforetest.field.dist2current.rew = as.data.table(beforetest.field.dist2current.rew)
beforetest.cell.db = as.data.table(beforetest.cell.db)

avg.pop.activity = function(binned.traces) {
  min.times_rew_cell = 1
  trace.dates = unique(binned.traces$date) %>% char2date()
  cell.db.daily =  beforetest.field.dist2current.rew[
    (date %in% trace.dates & animal == binned.traces$animal[1]), 
    .(animal, date, cell_id, signif.si)]
  cell.db = beforetest.field.dist2current.rew[
    (date %in% trace.dates & animal == binned.traces$animal[1]), 
    .(animal, date, cell_id, 
      signif.si,
      is.rew.cell = min.rew.dist <= min.rew.dist.thresh,
      is.signif.rew.cell = signif.si & (min.rew.dist <= min.rew.dist.thresh) )][
      ,.(times_signif_rew_cell = sum(is.signif.rew.cell),
         times_rew_cell = sum(is.rew.cell),
         times_signif_cell = sum(signif.si),
         npresent = .N,
         times_signif_rew_cell_pct = sum(is.signif.rew.cell) / .N),
      .(animal, cell_id)]
  # restrict to cells present on all 3 days
  sprintf('#cells at all three beforetests: %d', nrow(cell.db[npresent == 3, ]) ) %>% print
  sprintf('#signif reward cells amongst them: %d', 
          nrow(cell.db[npresent == 3 & times_signif_rew_cell >= min.times_rew_cell]) ) %>% print
  sprintf('# reward cells amongst them: %d',
          nrow(cell.db[npresent == 3 & times_rew_cell >= 2]) ) %>% print
  #joined.data.traces = merge(binned.traces, cell.db, by=c('animal','cell_id'), all.x = TRUE)
  joined.data.traces = merge(binned.traces, cell.db.daily, by=c('animal','cell_id', 'date'), all.x = TRUE)
  joined.data.traces[, min.rew.dist := pmin(dist_reward0, dist_reward1)]
  #joined.data.traces[, is.rew.cell := (times_signif_rew_cell >= min.times_rew_cell)]
  #joined.data.traces[, rew.cell.group := 0]
  #joined.data.traces[, rew.cell.group := pmin(times_signif_rew_cell, 2)]
  #joined.data.traces[, rew.cell.group := as.integer(times_signif_rew_cell_pct >= 0.5)]
  #joined.data.traces[, rew.cell.group := pmin(pmin(1, times_signif_rew_cell) * times_rew_cell, 2)]
  #joined.data.traces[, rew.cell.group := (times_signif_cell / npresent >= 0.5)]
  joined.data.traces[, rew.cell.group := as.integer(signif.si)]
  joined.data.traces[, close2rew := as.integer(min.rew.dist <= min.rew.dist.thresh) + 1]  
  joined.data.traces[, cell.active := zscored_smooth_deconv_trace >= 0.5]

  pop.traces.rew.cells = joined.data.traces[,#(npresent == 3) & (rew.cell.group != 1), 
                                            #.(avg.val = mean(smoothed_deconv_trace)),
                                            .(avg.val = mean(response_bin)-1),
                                            #.(avg.val = mean(cell.active)),
                                            by=list(animal, date, exp_title, trial_id, trial, x, y,
                                                    close2rew, min.rew.dist, timestamp, time_bin, rew.cell.group)]
  #pop.traces.rew.cells$cell_id = cell.db[npresent==3, cell_id][1]
    # workaround to use existing cell ids
  #cell.group.cell.id = joined.data.traces[,#(npresent == 3), 
  #                                        .(fst.cell_id=cell_id[1]), by=list(rew.cell.group)]
  #pop.traces.rew.cells = pop.traces.rew.cells[cell.group.cell.id, on=.(rew.cell.group)]
  #pop.traces.rew.cells$cell_id = pop.traces.rew.cells$fst.cell_id
  pop.traces.rew.cells$cell_id = pop.traces.rew.cells$rew.cell.group
  pop.traces.rew.cells[timestamp <= 120000, ]
}

pop.bayes.atreward.decoder.config = mfr.bayes.atreward.decoder.config
pop.bayes.atreward.decoder.config$predictor.var = quo(avg.val)
beforetest.pop.oneydayout.reward = eval.decoder.all.other.days(
  pop.bayes.atreward.decoder.config, 
  #filter(test.days.df, animal %in% c('E-BL', 'E-TR', ''),
  test.days.df,
  equal.prior = TRUE,
  prepare.vars.fun = avg.pop.activity,
  filter.train.traces.fun = function(binned.traces) {
    binned.traces[min.rew.dist <= 15/perc2dist | min.rew.dist >= 40 / perc2dist, ]
  },
  filter.test.traces.fun = filter.at.present.or.future.rew,
  test.day.indecies=c(1,3),
  min.ncells.for.eval=1,
  min.present.times=3)
```


```{r}
beforetest.pop.oneydayout.reward.summary = beforetest.pop.oneydayout.reward %>%
  left_join(mouse.meta.df) %>%
  left_join(trials.meta.df, by=c('animal'='animal', 'test_date'='date')) %>%
  group_by(implant, animal, test_date) %>%
  dplyr::summarise(mean.error=mean(error), sem.error=sem(error), 
                   mean.rand.error=mean(random_error)) %>%  
  dplyr::mutate(mean.rand.diff=mean.rand.error-mean.error)
    
beforetest.pop.oneydayout.reward.summary %>% 
  group_by(implant) %>%
  dplyr::summarise(mean(mean.error), sem(mean.error), 
                   mean(mean.rand.diff), sem(mean.rand.diff))

beforetest.pop.oneydayout.reward.summary %>% 
  group_by(implant, animal) %>%
  dplyr::summarise(mean(mean.error), sem(mean.error), 
                   mean(mean.rand.diff), sem(mean.rand.diff)) %>% View
```


```{r}
g = ggplot(beforetest.pop.oneydayout.reward.summary, 
           aes(text=animal, test_day=test_date)) +
  geom_jitter(aes(x=implant, y=100*mean.rand.diff, color=implant),
              shape=1, height=0, width=0.15, size=0.5) +
  geom_hline(yintercept = 0, linetype='dashed') +
  scale_color_manual(values=main.two.colours) +
  gtheme +
  theme(legend.position = 'none') +
  xlab('') + ylab('Accuracy (%)') + ylim(c(-50,50)) + ggtitle('Population decoder')
#ggsave('at_rew_classifier_pop_activity.pdf', g, device=cairo_pdf,
#       path='/home/prez/tmp/cheeseboard/', units='cm', width=3.0, height=3.2)
ggplotly(g)
ggsave('at_rew_pop_classifier.pdf', g, device=cairo_pdf,
       path='/home/prez/tmp/cheeseboard/', units='cm', width=3.0, height=3.75)

m = lmer.test.print(
  filter(beforetest.pop.oneydayout.reward.summary, implant=='dCA1'),
  var=mean.rand.diff,
  fixed.effects = 1,
  randef.str = '(1 | animal)',
  diagnostics.groupvar = implant)

m.full = BayesFactor::lmBF(mean.rand.diff ~ 1 + animal, 
                           data=filter(beforetest.pop.oneydayout.reward.summary, implant=='dCA1'),
                           whichRandom = 'animal', 
                           #rscaleRandom = rscaleRandom, 
                           #rscaleFixed = rscaleFixed,
                           iterations = 10000)
m.full
m.full = BayesFactor::ttestBF(subset(beforetest.pop.oneydayout.reward.summary, implant=='dCA1')$mean.rand.diff)

samples = BayesFactor::posterior(m.full, iterations = 10000)
quantile(samples[, 'mu'], c(0.025, 0.975))
```



# Stats on cells receall
How many cells recalled on all three days of beforetest
```{r}
as.data.table(beforetest.cell.db)[, .(ntimes=.N), by=.(implant, animal, cell_id)][ntimes>=3][, .N, by=.(animal)]
```
How many cells present on habituation days
```{r}
as.data.table(place.cell.db)[exp=='habituation', .(ncells=.N), by=.(implant, animal, date)][, mean(ncells), by=.(animal)]
```

How many cells recalles between two habit days
```{r}
as.data.table(place.cell.db)[exp=='habituation', .(ntimes=.N), by=.(implant, animal, cell_id)][ntimes>=2][, .N, by=.(animal)]
```
How many cells during habit day
```{r}
as.data.table(place.cell.db)[exp=='habituation', .(ncells=.N), by=.(implant, animal, day_desc)][,min(ncells), by=.(animal)]
# how many vca1 sessions with >= 30 cells
as.data.table(place.cell.db)[exp=='habituation', .(ncells=.N), by=.(implant, animal, day_desc)][implant=='vCA1', ncells >= 30] %>% mean
```


#Alternative Caret models
```{r}
library(caret)
```
```{r}
animal.caimg_dirs = find.caimg.dir(test_caimg_dirs, 'G-BR', '2020-02-08')
data.traces = read.data.trace(animal.caimg_dirs, filter_exp_title = 'beforetest')
binned.traces = prepare.traces(data.traces,
                               filter.running=TRUE,
                               timebin.dur.msec = 400,
                               get.bin.thresholds.fun = get.quantiles.fun(c(0.9, 1.0)),
                               binned.var='zscored_trace')
binned.traces = add.close2rew.fun(goal.cell.max.dist)(binned.traces)
```
Issue with unbalanced data: assigns the same class
```{r}
library(caret)
setorder(binned.traces, animal, date, trial, time_bin, timestamp)
binned.traces$close2rew = factor(binned.traces$close2rew, labels = c('not.at.rew', 'at.rew'))

wide.traces.df = tidyr::pivot_wider(
  binned.traces,
  id_cols=c(animal, date, trial, timestamp, time_bin, close2rew),
  names_from='cell_id',
  names_prefix='cell_',
  #values_from='smoothed_deconv_trace')
  values_from='response_bin')

inTraining <- 1: round(0.7 * nrow(wide.traces.df))

id.cols = 1:5
training <- wide.traces.df[ inTraining,-id.cols]
testing  <- wide.traces.df[-inTraining,-id.cols]

up.train.data = upSample(x = dplyr::select(training, -close2rew),
                           y = training$close2rew,
                           yname = 'close2rew')

fitControl <- trainControl(## 5-fold CV
                           method = "repeatedcv",
                           number = 5,
                           repeats = 3,
                           classProbs = TRUE)
                           #summaryFunction = twoClassSummary)

training.data.recipe = recipes::recipe(close2rew ~ .,
                                       training) %>%
  recipes::step_center(contains('cell_')) %>%
  recipes::step_scale(contains('cell_')) 
  #recipes::step_pca(contains('cell_'), prefix = 'principal_comp_',  threshold = .9) 

library(pROC)
gbmFit1 <- train(#close2rew ~ ., 
                 #data = training,
                 training.data.recipe, training,
                 #method = 'svmLinear',
                 #method='LogitBoost',
                 #method = 'gbm', 
                 method='lssvmRadial',
                 #trControl = fitControl,
                 #metric='ROC',
                 #tuneGrid=data.frame(C=c(0.25, 0.5, 1.0, 10.0)),
                 trControl = trainControl('none'),
                 ## This last option is actually one
                 ## for gbm() that passes through
                 verbose = FALSE)
predictors(gbmFit1)
summary(gbmFit1)
#plot(gbmFit1)
PredictedTest <- predict(gbmFit1, testing)
#Accuracy(PredictedTest, testTrainData$label)
mean(PredictedTest == testing$close2rew )
table(PredictedTest, testing$close2rew) / length(testing$close2rew)
mean(as.integer(PredictedTest))
```


```{r}
pivot.traces.wide = function(binned.traces,
                             predictor.var,
                             predicted.var) {
  predicted.var = enquo(predicted.var)
  predictor.var = enquo(predictor.var)
  predicted.varname = quo_name(predicted.var)
  predictor.varname = quo_name(predictor.var)
  #binned.traces$response_bin = as.factor(binned.traces$response_bin)
  id.cols = c('animal', 'date', 'trial', 'timestamp', 'time_bin')
  if (predicted.varname %in% colnames(binned.traces)) {
    id.cols = c(id.cols, predicted.varname)
  }
  res = tidyr::pivot_wider(
    binned.traces,
    id_cols=id.cols,
    names_from='cell_id',
    names_prefix='cell_',
    values_from=predictor.varname) %>%
    dplyr::select(!!predicted.var, starts_with('cell'))
  res[[predicted.varname]] = as.factor(paste0('class_', res[[predicted.varname]]))
  
  res
}

caret.svm.train = function(binned.traces,
                           nclasses, 
                           predictor.var,
                           predicted.var) {
  predictor.var = enquo(predictor.var)
  predicted.var = enquo(predicted.var)
  predicted.varname = quo_name(predicted.var)
  wide.traces.df = pivot.traces.wide(binned.traces, !!predictor.var, !!predicted.var)
  
  # upsample classes
  class.values = wide.traces.df[[predicted.varname]]
  up.train.data = upSample(x = dplyr::select(wide.traces.df, -c(!!predicted.var)),
                           y = class.values,
                           yname = predicted.varname)
  
  classifier.formula = as.formula(paste(predicted.varname, '~ .'))
  
  training.data.recipe = recipes::recipe(classifier.formula, up.train.data) %>%
    recipes::step_center(contains('cell_')) %>%
    recipes::step_scale(contains('cell_')) 
    #recipes::step_pca(contains('cell_'), prefix = 'principal_comp_',  threshold = .9) 
  
  svmFit <- train(#classifier.formula,
                  #data = wide.traces.df, 
                  training.data.recipe, 
                  up.train.data,
                  method = 'svmLinear',
                  #method='lssvmRadial',
                  #method = 'gbm', 
                  #metric='ROC',
                  tuneGrid=data.frame(C=c(0.25)),
                  #trControl = trainControl('none', classProbs = TRUE),
                  trControl = trainControl('none')
                  #method = 'LogitBoost',
                  #method='gbm',
                  #trControl = fitControl,
                  #verbose=FALSE
                  )
  
  sprintf('Created %d predictors from %d cells', length(predictors(svmFit)), ncol(wide.traces.df)-1) %>% print()
  prior.table = table(wide.traces.df[[predicted.varname]]) / nrow(wide.traces.df)
  prior.vec = as.vector(prior.table)
  list(prior=prior.vec, likelihood=svmFit)
}

caret.atreward.decoder.config = list(
  predicted.var = quo(close2rew),
  #predictor.var = quo(smoothed_deconv_trace),
  #predictor.var = quo(zscored_trace),
  predictor.var = quo(response_bin),
  #predictor.var = quo(avg.val),
  nclasses = 2,
  train.fun = caret.svm.train,
  predict.fun = caret.svm.predict,
  error.fun = function(x,y) {abs(x-y)}
)
```

#Decoding if at reward from cell activity
```{r include=FALSE}
beforetest.onedayout.cell.reward.svm = eval.decoder.all.other.days(
  caret.atreward.decoder.config, 
  test.days.df,
  equal.prior = TRUE,
  prepare.vars.fun = add.close2rew.fun(goal.cell.max.dist),
  filter.train.traces.fun = function(binned.traces) {
    binned.traces[pmin(dist_reward0, dist_reward1) <= 15/perc2dist | pmin(dist_reward0, dist_reward1) >= 40 / perc2dist, ]
  },
  filter.test.traces.fun = filter.at.present.or.future.rew,
  min.ncells.for.eval = 10,
  min.present.times = 3,
  test.day.indecies=c(1,3))
```

```{r}
beforetest.onedayout.cell.reward.svm.summary = beforetest.onedayout.cell.reward.svm %>%
  left_join(mouse.meta.df) %>%
  left_join(trials.meta.df, by=c('animal'='animal', 'test_date'='date')) %>%
  group_by(implant, animal, test_date) %>%
  dplyr::summarise(mean.error=mean(error), sem.error=sem(error), 
                   mean.rand.error=0.5) %>%  
  dplyr::mutate(mean.rand.diff=mean.rand.error-mean.error)
  
beforetest.onedayout.cell.reward.svm.summary %>% 
  group_by(implant) %>%
  dplyr::summarise(mean(mean.error), sem(mean.error), 
                   mean(mean.rand.diff), sem(mean.rand.diff))
```
```{r}
g = ggplot(beforetest.onedayout.cell.reward.svm.summary, 
           aes(text=animal, test_day=test_date)) +
  geom_jitter(aes(x=implant, y=100*mean.rand.diff, color=implant),
              shape=1, height=0, width=0.15, size=0.5) +
  geom_hline(yintercept = 0, linetype='dashed') +
  scale_color_manual(values=main.two.colours) +
  gtheme +
  theme(legend.position = 'none') +
  xlab('') + ylab('Accuracy above random (%)') + ylim(c(-50,50)) + ggtitle('SVM cell decoder')

ggplotly(g)
```


#Decoding if at reward from population activity
```{r include=FALSE}
beforetest.onedayout.reward.svm = eval.decoder.all.other.days(
  caret.atreward.decoder.config, 
  test.days.df,
  #ncells = 0,
  #nshuffles = 1,
  equal.prior = TRUE,
  prepare.vars.fun = avg.pop.activity,
  # prepare.vars.fun = function(df) {
  #   df[, min.rew.dist := pmin(dist_reward0, dist_reward1)]
  #   df[, close2rew := as.integer(min.rew.dist <= goal.cell.max.dist) + 1]
  #   df
  # },
  # prepare.vars.fun = function(df) {
  #   df = df[timestamp <= 120000, ]
  #   df[, min.rew.dist := pmin(dist_reward0, dist_reward1)]
  #   avg.df = avg.pop.activity(df)
  #   avg.df$cell_id = avg.df$cell_id + 1000
  #   df[, avg.val := response_bin-1]
  #   df[, close2rew := as.integer(min.rew.dist <= goal.cell.max.dist) + 1]
  #   df = df[, .(animal, date, exp_title, trial_id, trial, x, y, close2rew, min.rew.dist, timestamp, time_bin, avg.val, cell_id)]
  #   df$rew.cell.group = FALSE
  #   res = data.table::rbindlist(list(df, avg.df), fill=TRUE)
  #   res
  # },
  filter.train.traces.fun = function(binned.traces) {
    #binned.traces[pmin(dist_reward0, dist_reward1) <= 15/perc2dist | pmin(dist_reward0, dist_reward1) >= 40 / perc2dist, ]
    binned.traces[min.rew.dist <= 15/perc2dist | min.rew.dist >= 40 / perc2dist, ]
  },
  filter.test.traces.fun = filter.at.present.or.future.rew,
  test.day.indecies=c(1,3),
  min.ncells.for.eval = 1,
  min.present.times = 3)
```

```{r}
beforetest.onedayout.reward.svm.summary = beforetest.onedayout.reward.svm %>%
  left_join(mouse.meta.df) %>%
  left_join(trials.meta.df, by=c('animal'='animal', 'test_date'='date')) %>%
  group_by(implant, animal, test_date) %>%
  dplyr::summarise(mean.error=mean(error), sem.error=sem(error), 
                   mean.rand.error=mean(random_error), sem.rand.error=sem(random_error)) %>%  
  dplyr::mutate(mean.rand.diff=mean.rand.error-mean.error)
  
beforetest.onedayout.reward.svm.summary %>% 
  group_by(implant) %>%
  dplyr::summarise(mean(mean.error), sem(mean.error), 
                   mean(mean.rand.diff), sem(mean.rand.diff),
                   mean(mean.rand.error), sem(mean.rand.error))

beforetest.onedayout.reward.svm.summary %>% 
  group_by(implant, animal, test_date) %>%
  dplyr::summarise(mean(mean.error), sem(mean.error), 
                   mean(mean.rand.diff), sem(mean.rand.diff),
                   mean(mean.rand.error), sem(mean.rand.error)) %>% View
```
```{r}
g = ggplot(beforetest.onedayout.reward.svm.summary, 
           aes(text=animal, test_day=test_date)) +
  geom_jitter(aes(x=implant, y=100*mean.rand.diff, color=implant),
              shape=1, height=0, width=0.15, size=0.5) +
  geom_hline(yintercept = 0, linetype='dashed') +
  scale_color_manual(values=main.two.colours) +
  gtheme +
  theme(legend.position = 'none') +
  xlab('') + ylab('Accuracy above random (%)') + ylim(c(-50,50)) + ggtitle('Population decoder')

ggplotly(g)

m = lmer.test.print(
  filter(beforetest.onedayout.reward.svm.summary, implant=='dCA1'),
  var=mean.rand.diff,
  fixed.effects = 1,
  randef.str = '(1 | animal)',
  diagnostics.groupvar = implant)

m.full = BayesFactor::lmBF(mean.rand.diff ~ 1 + animal, 
                           data=filter(beforetest.onedayout.reward.svm.summary, implant=='dCA1'),
                           whichRandom = 'animal', 
                           #rscaleRandom = rscaleRandom, 
                           #rscaleFixed = rscaleFixed,
                           iterations = 10000)
m.full
BayesFactor::ttestBF(subset(beforetest.onedayout.reward.svm.summary, implant=='dCA1')$mean.rand.diff)

models = create.bayes.lm.pair(beforetest.onedayout.reward.svm.summary,
                     formula.full = mean.rand.diff ~ 1 + animal,
                     formula.null = mean.rand.diff ~ 1 + animal,
                     whichRandom = 'animal',
                     iterations = 100000)
models$full / models$null
calc.pair.95CI(models$full, show.percent.change = FALSE)
```

